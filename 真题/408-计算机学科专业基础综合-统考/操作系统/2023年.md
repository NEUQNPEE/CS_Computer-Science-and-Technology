# 一、单项选择题

第01~40小题，每小题2分，共80分。下列每题给出的四个选项中，只有一个选项是最符合题目要求的。

## 23.
与宏内核操作系统相比，下列特征中微内核操作系统具有的是（ ）。

Ⅰ. 较好的性能

Ⅱ. 较高的可靠性

Ⅲ. 较高的安全性

Ⅳ. 较强的可扩展性

A. Ⅱ、Ⅳ

B. Ⅰ、Ⅱ、Ⅲ

C. Ⅰ、Ⅲ、Ⅳ

D. Ⅱ、Ⅲ、Ⅳ

解答：

微内核是提供操作系统核心功能的内核的精简版本，它设计成在很小的内存空间内增加移植性，提供模块化设计，以使用户安装不同的接口。

微内核操作系统的优点：

①提高了系统的可扩展性。

②增强了系统的可靠性。

③可移植性强。

④提供了对分布式系统的支持

⑤融入了面相对象的技术。

I错误。微内核操作系统相比宏内核操作系统运行效率有所降低。在微内核操作系统中，因为客户和服务器、服务器和服务器直接的通信都需要通过微内核，所以在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式与上下文的切换。

Ⅱ正确。微内核操作系统的设计理念是将核心操作系统功能限制在最小的内核中，将其他功能模块以外部服务的形式运行在用户态。这种设计使得操作系统核心更小、更简单，减少了代码复杂度和错误产生的可能性，从而提高了系统的可靠性。

Ⅲ正确。微内核操作系统通过将功能划分为不同的服务来实现，这些服务以独立的地址空间运行，彼此之间隔离，因此相对较容易实现安全性控制。由于核心内核非常简单，少量的核心代码意味着较少的漏洞和攻击面，从而提高了系统的安全性。

Ⅳ正确。微内核操作系统的设计使得各个功能模块以外部服务的形式存在，可以动态地加载和卸载这些服务模块，从而实现系统的灵活可扩展性。新的功能可以以插件或模块的形式添加，而不需要修改核心内核，这样可以减少对系统其他模块的影响，提高了系统的可扩展性。

综上，Ⅱ、Ⅲ、Ⅳ正确。

本题选D。



## 24.
在操作系统内核中，中断向量表适合采用的数据结构是（ ）。

A. 数组

B. 队列

C. 单向链表

D. 双向链表

解答：

中断向量表是用于存储中断处理程序入口地址的数据结构。中断向量表的索引对应着中断类型号或中断向量号，而其中存储的值是对应中断类型的处理程序的入口地址。

使用数组作为中断向量表的数据结构有以下几个优点：

①快速访问：数组通过索引可以直接定位到对应位置的中断处理程序入口地址，具有常量时间复杂度的访问性能。这是因为中断类型号或中断向量号是连续的整数，可以通过简单的计算得到对应的数组下标。

②紧凑存储：由于中断类型号或中断向量号是连续的整数，使用数组可以直接按照顺序将中断处理程序的入口地址存储在连续的内存空间中，这样可以节省内存空间。

因此，中断向量表适合采用数组作为数据结构。

四个选项中也只有选项A支持随机访问。

本题选A。



## 25.
某系统采用页式存储管理，用位图管理空闲页框。若页大小为4 KB，物理内存大小为16 GB，则位图所占空间的大小是（ ）。

A. 128 B

B. 128 KB

C. 512 KB

D. 4 MB

解答：

因为物理内存大小为16 GB，页大小为4 KB，页框大小与页大小相等，页框数量最大为16 GB/4 KB = $2^{22}$，因为采用位图法，每个页框状态只需要1个比特位表示，所以位图所占的空间大小为$2^{22}$ ×1 bit = 512 KB。

本题选C。



## 26.
下列操作完成时，导致CPU从内核态转为用户态的是（ ）。

A. 阻塞过程

B. 执行 CPU 调度

C. 唤醒进程

D. 执行系统调用

解答：

A错误。阻塞过程完成时，某进程从运行态进入阻塞态。

B错误。执行 CPU 调度完成时，某进行从就绪态进入运行态。

C错误。在操作系统中，当一个进程发起某种需要等待的操作（如等待I/O操作完成或等待某个信号），它会被标记为睡眠状态，然后被放入等待队列中。当满足等待条件时，操作系统会将进程从等待队列中唤醒，使其重新变为可执行状态。

D正确。当CPU执行的系统调用完成时，会触发从内核态转换到用户态。系统调用是用户程序通过请求操作系统提供的服务或资源的一种机制，当用户程序需要执行特权操作或获取系统资源时，会通过系统调用发出请求。在执行系统调用期间，CPU首先会从用户态切换到内核态，然后操作系统执行相应的操作，最后该操作完成时，CPU将再次切换回用户态。系统调用结束后，CPU可以继续执行用户程序。因此，执行系统调用包含CPU从内核态转换到用户态的操作。

本题选D。



## 27.
下列出当前线程引起的事件或执行的操作中，可能导致该线程由执行态变为就绪态的是（ ）。

A. 键盘输入

B. 缺页异常

C. 主动出让CPU

D. 执行信号量的wait()操作

解答：

A错误。发生键盘输入后，该线程可能需要等待键盘输入完成，说明该线程不具有执行所需的所有系统资源，进入阻塞态。

B错误。发生缺页异常后，该线程可能需要等待缺页处理程序处理完成，说明该线程不具有执行所需的所有系统资源，进入阻塞态。

C正确。该线程主动出让CPU后，不再不占用CPU，进入就绪态。

D错误。该线程执行信号量的wait()操作，说明该线程不具有执行所需的所有系统资源，如果信号量条件不满足，则进入阻塞态。

本题选C。

总结

就绪态、阻塞态、运行态与处理机、运行需要的系统资源的关系如下：

| 状态   | 是否占用处理机 | 是否具有所需的系统资源 |
| ------ | -------------- | ---------------------- |
| 就绪态 | 否             | 是                     |
| 运行态 | 是             | 是                     |
| 阻塞态 | 否             | 否                     |


就绪态、阻塞态、运行态的转化方向如下：

![Alt text](images/image.png)


## 28.
对于采用虚拟内存管理方式的系统，下列关于进程虚拟地址空间的叙述中，错误的是（ ）。

A. 每个进程都有自己独立的虚拟地址空间

B. C语言中malloc( )函数返回的是虚拟地址

C. 进程对数据段和代码段可以有不同的访问权限

D. 虚拟地址的大小由主存和硬盘的大小决定

解答：

A正确。每个进程在运行时都被分配了独立的虚拟地址空间。

B正确。C语言中malloc()函数用于动态内存分配，返回的是一个指向分配内存的虚拟地址。

C正确。操作系统可以对进程的不同部分设置不同的权限，例如只读、可读写等。

D错误。虚拟地址空间的大小由操作系统决定。计算机系统一般按字节编址，32位操作系统的虚拟地址空间的大小为 $2^{32}$ B = 4 GB，64位操作系统的虚拟地址空间的大小为 $2^{64}$ B = 16 EB。虚拟地址空间的大小与主存和硬盘的大小无关。

本题选D。



## 29.
进程P1、P2和P3进入就绪队列的的时刻，优先级（越大优先权越高）以及CPU的执行时间如下表所示。

| 进程名 | 进入就绪队列的时刻 | 优先级 | CPU执行时间 |
| ------ | ------------------ | ------ | ---------- |
| P1     | 0ms                | 1      | 60ms       |
| P2     | 20ms               | 10     | 42ms       |
| P3     | 30ms               | 100    | 13ms       |

系统采用基于优先权的抢占式CPU调度算法，从0ms时刻开始进行调度，则P1、P2和P3的平均周转时间为（ ）。

A. 60 ms

B. 61 ms

C. 70 ms

D. 71 ms

解答：

按时间序列进程分析：

0ms时刻，只有P1进入就绪队列，开始运行P0。

20ms时刻，P2进入就绪队列，P1运行了20ms-0ms=20ms，其CPU执行时间为60ms，剩余CPU执行时间为60ms-20ms=40ms。就绪队列中存在P1和P2两个进程。系统采用基于优先权的抢占式进程调度算法，P2优先级值比P1优先级值大，值越大优先权越高，P2抢占执行。

30ms时刻，P3进入就绪队列，P2运行了30ms-20ms=10ms，其CPU执行时间为42ms，剩余CPU执行时间为42ms-10ms=32ms。就绪队列中存在P1、P2、P3三个进程，此时所有进程都以就绪，系统采用基于优先权的抢占式进程调度算法，值越大优先权越高，优先级值从大到小依次为P3、P2、P1，此时P3抢占执行。

30ms+13ms=43ms时刻，P3执行完毕，P2执行。

43ms+32ms=75ms时刻，P2执行完毕，P1执行。

75ms+40ms=115ms时刻，P1执行完毕，此时所有进程均已执行完毕。

进程周转时间 = 进程完成时刻-进程进入就绪队列的时刻。

P1周转时间 = P1进程完成时刻-P1进程进入就绪队列的时刻 = 115ms-0ms = 115ms；

P2周转时间 = P2进程完成时刻-P2进程进入就绪队列的时刻 = 75ms-20ms = 55ms；

P3周转时间 = P3进程完成时刻-P3进程进入就绪队列的时刻 = 43ms-30ms = 13ms；

P1、P2和P3的平均周转时间 = (P1周转时间 + P2周转时间 + P3周转时间)/3 = 61ms。

本题选B。



## 30.
进程R和S共享数据data，若data在R和S中所在页的页号分别为p1和p2，两个页所对应的页框号分别为f1和f2，则下列叙述中，正确的是（ ）。

A. p1 和 p2 一定相等，f1 和 f2 一定相等

B. p1 和 p2 一定相等，f1 和 f2 不一定相等

C. p1 和 p2 不一定相等，f1 和 f2 一定相等

D. p1 和 p2 不一定相等，f1 和 f2 不一定相等

解答：

每个进程的虚拟地址空间是独立的，它们使用的页号是相对于各自的地址空间的。对于进程 R 和 S 共享的数据 data，可能位于不同的页面中，因此其对应的页号 p1 和 p2 不一定相等。

一段数据物理地址空间是确定的，对应的起始页框号是唯一的。对于进程 R 和 S 共享的数据 data，位于同一个页框中，因此两个页所对应的页框号分别为 f1 和 f2 一定相等。

本题选C。



## 31.
若文件F仅被进程P打开并访问，则当进程P关闭F时，下列操作中，文件系统需要完成的是（ ）。

A. 删除目录中文件F的目录项

B. 释放F的索引节点所占的内存空间

C. 释放F的索引节点所占的外存空间

D. 将文件磁盘索引节点中的链接计数减1

解答：

索引节点是文件系统中用来记录文件的元数据的数据结构，包括索引节点编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样会被持久化到磁盘，所以，索引节点同样占磁盘。

链接计数是文件系统用于统计一个文件被引用的次数，每当有一个进程打开该文件时，链接计数就会加1。当进程关闭文件时，文件系统会相应地将链接计数减1。当链接计数减到0时，表示没有任何进程打开该文件了，文件系统可以将其相关的资源进行释放。

A错误。进程P可以通过目录中文件F的目录项再次访问文件F，暂时不能删除。

B正确。由于初始时文件F仅被进程P打开并访问，索引节点中的链接计数为1。当进程P关闭文件F时，文件系统需要完成的操作是将文件内存索引节点中的链接计数减1，此时索引节点中的链接计数减1后为0，表示没有任何进程打开该文件了，文件系统可以将其相关的资源进行释放，包括文件F的索引节点所占的内存空间，文件F的所占的内存空间。

C错误。题目要求关闭文件F，没有要求删除文件F。只有执行删除文件F，文件磁盘索引节点中的链接计数减1，当磁盘索引节点引用计数为0的时候，会释放F的索引节点所占的外存空间，如果该索引节点为硬链接的索引节点，那么还需要释放文件F指向的文件实体所占的外存空间。当释放F的索引节点所占的外存空间后，该索引节点不复存在，也就无法在外存中通过该索引节点访问文件F。

D错误。题目要求关闭文件F，没有要求删除文件F，磁盘索引节点计数中的链接计数不受影响。

本题选B。



## 32.
下列因素中，设备分配需要考虑的是（ ）。

Ⅰ. 设备的类型

Ⅱ. 设备的访问权限

Ⅲ. 设备的占用状态

Ⅳ. 逻辑设备与物理设备的映射关系

A. Ⅰ、Ⅱ

B. Ⅱ、Ⅲ

C. Ⅲ、Ⅳ

D. Ⅰ、Ⅱ、Ⅲ、Ⅳ

解答：

Ⅰ正确。设备分配需要考虑设备的类型。不同类型的设备有不同的特性和操作方式，因此在进行设备分配时需要根据设备的类型进行相应的处理。

Ⅱ正确。设备分配需要考虑设备的访问权限。某些设备可能需要受限制地访问，只允许特定的进程或用户进行访问，而其他进程或用户则被禁止访问。

Ⅲ正确。设备分配时需要考虑设备的占用状态。如果设备已经被其他进程或用户占用，那么在进行设备分配时就需要进行相应的冲突检测和资源管理，以确保设备的正确分配和互斥使用。

Ⅳ正确。设备分配涉及到逻辑设备与物理设备的映射关系。在计算机系统中，逻辑设备是通过操作系统层面进行管理的，而物理设备则是实际的硬件设备。设备分配需要建立逻辑设备与物理设备之间的映射关系，以便进行设备的访问和控制。

综上所述，设备分配需要考虑Ⅰ、Ⅱ、Ⅲ、Ⅳ。

本题选D。



# 二、综合应用题
第41~47小题，共70分。

45.
（7分）

现要求学生使用 swap 指令和布尔型变量 lock 实现临界区互斥。lock 为线程间共享的变量。lock 的值为 TRUE 时线程不能进入临界区，为 FALSE 时线程能够进入临界区。某同学编写的实现临界区互斥的伪代码如题 45(a) 图所示。


(1) 题 45(a) 图中伪代码中哪些语句存在错误？将其改为正确的语句（不增加语句条数）。

(2) 题 45(b) 图中给出了两个变量值的函数 newSwap() 的代码是否可以用函数调用语句“newSwap(&key, &lock)”代替指令“swap key, lock”以实现临界区的互斥？为什么？

解答：

本题问题(1)考察Swap指令的应用，问题(2)考察Swap指令用硬件逻辑实现的原因。

假设线程T0和T1均要访问临界区，伪代码如下：

```c
bool lock = FALSE;    // 共享变量
...
void T0() {
    bool key = TRUE;
    if (key == TRUE)
        swap key, lock;    // 交换key和lock的值
    临界区;
    lock = TRUE;
    ...
}
void T1() {
    bool key = TRUE;
    if (key == TRUE)
        swap key, lock;    // 交换key和lock的值
    临界区;
    lock = TRUE;
    ...
}
```

(1) 按照上述伪代码执行，发现线程T1和T2均能够进入临界区，无法实现互斥访问临界区。

执行“swap key, lock;”后，key为FALSE，lock为TRUE，lock为TRUE满足进入临界区前上锁条件，key为FALSE可以进入临界区，所以key为TRUE应该起到拦截效果，同时为了进入临界区，需要进行轮询。所以第一处修改如下：

①进入区中的语句“if (key == TRUE) swap key, lock;”存在错误，修改为“while (key == TRUE) swap key, lock;”。

此外，退出临界区后需要进行解锁，否则其他线程无法访问临界区。所以第二处修改如下：

②退出区中的语句“lock = TRUE;”存在错误，修改为“lock = FALSE;”。

修改后如下线程T0和T1访问临界区的伪代码如下：

```c
bool lock = FALSE;    // 共享变量
...
void T0() {
    bool key = TRUE;
    while (key == TRUE)
        swap key, lock;    // 交换key和lock的值
    临界区;
    lock = FALSE;
    ...
}
void T1() {
    bool key = TRUE;
    while (key == TRUE)
        swap key, lock;    // 交换key和lock的值
    临界区;
    lock = FALSE;
    ...
}
```
实现了多线程互斥访问临界区。

(2) 第一问。否。

第二问。Swap指令为原子操作。但用函数调用语句“newSwap(&key, &lock)”代替指令“swap key, lock”后，因为多个线程可以并发执行newSwap()，newSwap()执行时传递给形参b的是共享变量lock的地址，在newSwap()中对lock既有读操作又有写操作，并发执行时不能保证实现两个变量值的原子交换，从而会导致并发执行的线程同时进入临界区。

将newSwap代替swap后，修正后的线程T0和T1访问临界区的伪代码如下：
```c
bool lock = FALSE;    // 共享变量
...
void T0() {
    bool key = TRUE;
    while (key == TRUE) {
        bool temp = key;   ①
        key = lock;        ②
        lock = temp;       ③
    }
    临界区;
    lock = FALSE;
    ...
}
void T1() {
    bool key = TRUE;
    while (key == TRUE) {
        bool temp = key;   ④
        key = lock;        ⑤
        lock = temp;       ⑥
    }
    临界区;
    lock = FALSE;
    ...
}
```
例如按照①②④⑤③⑥的顺序执行，则T0和T1能够同时进入临界区，进而产生冲突。

为了保证Swap指令的原子性，可使用的方案有通过软件加互斥锁实现或者通过硬件逻辑直接实现，相比使用软件加互斥锁实现的方案，通过硬件逻辑直接实现明显更加安全和高效。所以Swap指令是由硬件逻辑直接实现的，不会被中断。

## 46.
（8分）

进程P通过执行系统调用从键盘接收一个字符的输入，已知此过程中与进程P相关的操作包括：①将进程P插入就绪队列；②将进程P插入阻塞队列；③将字符从键盘控制器读入系统缓冲区；④启动键盘中断处理程序；⑤进程P从系统调用返回；⑥用户在键盘上输入字符。以上编号①~⑥仅用于标记操作，与操作的先后顺序无关。请回答下列问题。

(1) 按照正确的操作顺序，操作①的前一个和后一个操作分别是上述操作中的哪一个？操作⑥的后一个操作上述操作中的哪一个？

(2) 在上述哪个操作之后CPU一定从进程P切换到其他进程？在上述哪个操作之后CPU调度程序才能选择进程P执行？

(3) 完成上述哪个操作的代码属于键盘驱动程序？

(4) 键盘中断处理程序执行时，进程P处于什么状态？CPU处于内核态还是用户态？

解答：

(1) 正确的操作顺序如下：

②将进程P插入阻塞队列：由于进程P执行了从键盘接收输入的系统调用（例如执行C语言的scanf()函数），需要等待用户输入完成才能继续执行。因此，进程P会被插入阻塞队列，等待键盘中断处理程序的处理。

⑥用户在键盘上输入字符：用户在键盘上输入字符，键盘控制器会将字符传递给操作系统进行处理。

④启动键盘中断处理程序：当键盘控制器有新的输入字符时，会发出中断信号通知操作系统，启动相应的键盘中断处理程序。

③将字符从键盘控制器读入系统缓冲区：键盘控制器会将用户在键盘上输入的字符读入系统缓冲区，准备供后续处理。

①将进程P插入就绪队列：当键盘中断处理程序完成了对输入字符的处理，并且准备唤醒等待输入的进程时，会将进程P从阻塞队列移动到就绪队列，准备继续执行。

⑤进程P从系统调用返回：当进程P从阻塞队列移到就绪队列后，它会被调度执行。在该过程中，进程P会在系统调用结束后从系统调用返回，继续执行后续的指令。

综上，正确的操作顺序是②、⑥、④、③、①、⑤。

第一问。操作①的前一个操作是③，后一个操作是⑤。

第二问。操作⑥的后一个操作是④。

(2) 第一问。在上述操作中，CPU一定会从进程P切换到其他进程的操作是②

将进程P插入阻塞队列。当进程P被插入阻塞队列后，它无法继续执行，因此CPU会在此时切换到其他可执行的进程。

第二问。在上述操作中，CPU调度程序才能选择进程P执行的操作是①

将进程P插入就绪队列。当进程P被插入就绪队列后，CPU调度程序可以从就绪队列中选择它来执行。在此之前，进程P处于阻塞状态，不可被调度执行。只有当进程P被插入就绪队列后，CPU调度程序才有机会选择它作为下一个要执行的进程。

(3) 完成上述操作的代码属于键盘驱动程序的操作是③将字符从键盘控制器读入系统缓冲区。

键盘驱动程序负责与硬件键盘进行交互，并将键盘输入的字符传递给操作系统进行处理。在完成键盘输入的过程中，键盘驱动程序会读取键盘控制器的输入，将字符存储到系统缓冲区中，以便其他进程或系统调用可以访问该字符。

(4) 第一问。当键盘中断处理程序执行时，进程P处于阻塞状态。

因为当键盘中断处理程序被触发时，进程P已经执行了系统调用并被插入阻塞队列。该进程暂停执行，等待键盘输入的中断处理程序完成并将其从阻塞队列移动到就绪队列中。只有在进程P从阻塞队列移到就绪队列后，才有机会被CPU调度执行。因此，在键盘中断处理程序执行时，进程P处于阻塞状态或等待状态。

第二问。当键盘中断处理程序被触发时，CPU处于内核态。

键盘中断处理程序通常在内核态下执行，因为它需要对硬件进行直接的访问和操作，例如读取键盘控制器、处理键盘输入等。在内核态下执行可以获得更高的权限和对系统资源的直接访问能力，从而快速响应中断并处理相应的操作。